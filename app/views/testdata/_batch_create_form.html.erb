<%= form_for [@problem, @testdatum], url: :batch_create_problem_testdata, html: {multipart: true, id: 'testdata-form'}, remote: true, authenticity_token: true do |f| %>
  <%= render partial: "shared/errors", locals: {errors: @testdatum.errors, item: 'testdatum'} %>

  <div class="form-group">
    <%= f.label :testdata_file_list, "Testdata" %>
    <%= f.file_field :testdata_file_list, :class => 'form-control flat', multiple: true, onchange: "updateTestdataFile(event)" %>
  </div>
  
  <div id="testdata-list" class="panel panel-default">
    <div class="panel-heading" data-toggle="collapse" href="#collapseTestdata">
      <h1 class="panel-title">
        Testdata File List
        <i class="indicator glyphicon glyphicon-chevron-up pull-right"></i>
      </h1>
    </div>
    <div class="collapse in" id="collapseTestdata">
      <table class="table table-condensed table-align-middle">
        <thead>
          <tr>
            <th>Input Filename</th>
            <th>Output Filename</th>
          </tr>
        </thead>
        <tbody id="file-table">
        </tbody>
      </table>
    </div>
  </div>

  <div class="form-group">
    <%= f.label :time_limit, "Time Limit" %>
    <%= f.number_field :time_limit, class: 'form-control flat' %>
  </div>
  <div class="form-group">
    <%= f.label :vss_limit, "Memory Limit (VSS)" %>
    <%= f.number_field :vss_limit, class: 'form-control flat' %>
  </div>
  <div class="form-group">
    <%= f.label :rss_limit, "Memory Limit (RSS)" %>
    <%= f.number_field :rss_limit, class: 'form-control flat' %>
  </div>
  <div class="form-group">
    <%= f.label :output_limit, "Output Limit" %>
    <%= f.number_field :output_limit, class: 'form-control flat' %>
  </div>

  <div class="dummy-placeholder">
    <%= f.hidden_field :problem_id %>
  </div>

  <div class="form-group flex" style="display: flex; margin-bottom: 0.5em;">
    <div class="actions" style="margin-right: 1em; flex: 0 0 0%;">
      <%= f.submit class: 'btn btn-success btn-lg' %>
    </div>
    <div style="flex: 1 0 0%; ">
      <% ["filezip", "update"].each do |data|%>
        <div class="fade" id="progress-fade-<%= data %>" style="flex: 1 0 0%;">
          <div class="progress progress-striped active" role="progressbar" style="margin-bottom: 0.25em; border-radius: 4px; height: 20px; background: #f0faf0;">
            <div id="progress-inner-bar-<%= data %>" class="progress-bar progress-bar-success" style="width: 0%;"></div>
          </div>
          <div id="progress-text-<%= data %>" class="progress-extended small"></div>
        </div>
      <% end %>
    </div>
  </div>
<% end %>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
<script>
var file_list = [];
var file_pairs = [];

function buildIOCorrespondence() {
  file_pairs = [];
  const suffix_map = new Map(); // name -> idx
  const prefix_map = new Map(); // name -> idx
  var input_file_list = [];
  for (let idx = 0; idx < file_list.length; idx++) {
    let name = file_list[idx].name;
    if (name.endsWith('.out') || name.endsWith('.ans')) {
      suffix_map.set(name.slice(0, -4), idx);
    } else if (name.startsWith('out')) {
      prefix_map.set(name.slice(3), idx);
    } else {
      input_file_list.push(idx);
    }
  }
  const used_set = new Set();
  for (let i = 0; i < input_file_list.length; i++) {
    let idx = input_file_list[i];
    let name = file_list[idx].name;
    if (name.endsWith('.in')) {
      let out_name = name.slice(0, -3);
      if (suffix_map.has(out_name)) {
        let out_idx = suffix_map.get(out_name);
        used_set.add(idx);
        used_set.add(out_idx);
        file_pairs.push([idx, out_idx]);
        continue;
      }
    } else if (name.startsWith('in')) {
      let out_name = name.slice(2);
      if (prefix_map.has(out_name)) {
        let out_idx = prefix_map.get(out_name);
        used_set.add(idx);
        used_set.add(out_idx);
        file_pairs.push([idx, out_idx]);
        continue;
      }
    }
  }
  for (let idx = 0; idx < file_list.length; idx++) {
    if (!used_set.has(idx)) {
      file_pairs.push([null, idx]);
    }
  }
  file_pairs.sort((a, b) => {
    if (a[0] === null && b[0] === null) {
      return a[1] - b[1];
    }
    if (a[0] === null) {
      return 1;
    }
    if (b[0] === null) {
      return -1;
    }
    return a[0] - b[0];
  });
}

function refreshFileListTable() {
  let tmpTable = document.getElementById('file-table');
  tmpTable.innerHTML = '';
  for (let idx = 0; idx < file_pairs.length; idx++){
    let tmpRow = tmpTable.insertRow();
    let tmpCell = tmpRow.insertCell();
    if (file_pairs[idx][0] === null) {
      tmpCell.innerHTML = '<span class="text-danger" style="font-style:italic;">unmatched</span>';
      tmpRow.classList.add('warning');
    } else {
      tmpCell.innerText = file_list[file_pairs[idx][0]].name;
    }
    tmpCell = tmpRow.insertCell();
    tmpCell.innerText = file_list[file_pairs[idx][1]].name;
  }
}

function updateTestdataFile(event) {
  file_list = Array.from(event.target.files);
  buildIOCorrespondence();
  refreshFileListTable();
}

$(function () { $('#testdata-form').submit(function (event) {
    event.preventDefault();
    var _formatFileSize = function (bytes) {
      if (typeof bytes !== 'number') {
        return '';
      }
      if (bytes >= (1024*1024*1024)) {
        return (bytes / (1024*1024*1024)).toFixed(2) + ' GiB';
      }
      if (bytes >= (1024*1024)) {
        return (bytes / (1024*1024)).toFixed(2) + ' MiB';
      }
      if (bytes >= 1024) {
        return (bytes / 1024).toFixed(2) + ' KiB';
      }
      return (bytes * 1.0).toFixed(2) + ' byte';
    };
    var _formatTime = function (seconds) {
      var date = new Date(seconds * 1000), days = Math.floor(seconds / 86400);
      days = days ? days + 'd ' : '';
      if (date.getUTCHours() > 1) {
        days = days + ('0' + date.getUTCHours()).slice(-2) + ':';
      }
      return (
        days +
        ('0' + date.getUTCMinutes()).slice(-2) +
        ':' +
        ('0' + date.getUTCSeconds()).slice(-2)
      );
    };
    var _formatPercentage = function (floatValue) {
      return (floatValue * 100).toFixed(2) + ' %';
    };
    var _renderProgress = function (data) {
      return (
        _formatPercentage(data.loaded / data.total) +
        ' | ' +
        _formatFileSize(data.loaded) +
        ' / ' +
        _formatFileSize(data.total) +
        ' | ETA ' +
        _formatTime((data.total - data.loaded) / (data.byterate)) +
        ' | ' +
        _formatFileSize(data.byterate) +
        '/s'
      );
    };

    var filtered_list = file_pairs.filter((pair) => pair[0] !== null);
    if (filtered_list.length == 0){
      alert('No input files.');
      return;
    }
    if (filtered_list.length > 256){
      alert('Can only upload 256 testdata at once.');
      return;
    }

    var tmpData = new FormData(this);
    var formData = new FormData();

    var zipFile = new JSZip();
    var td_pairs = [];
    for (let [key, value] of tmpData.entries()) {
      if (key == 'testdatum[testdata_file_list][]') continue;
      formData.append(key, value);
    }
    var totalSize = 0;
    const MAX_SIZE = 2 * 1024 * 1024 * 1024;
    filtered_list.forEach((pair) => {
      zipFile.file(file_list[pair[0]].name, file_list[pair[0]], {compression: "DEFLATE"});
      zipFile.file(file_list[pair[1]].name, file_list[pair[1]], {compression: "DEFLATE"});
      if (file_list[pair[0]].size + file_list[pair[1]].size > MAX_SIZE) {
        alert('Individual testdatum should not exceed 2 GiB.');
        return;
      }
      totalSize += file_list[pair[0]].size + file_list[pair[1]].size;
      td_pairs.push([file_list[pair[0]].name, file_list[pair[1]].name]);
    });
    formData.append('testdatum[testdata_pairs]', JSON.stringify(td_pairs));

    let url = $(this).attr('action');
    var oldUrl = window.location.href;
    var xhr = null;
    zipFile.generateAsync({type: "blob"}, function updateCallback(progress) {
      $('#progress-fade-filezip').addClass('in');
      $('#progress-inner-bar-filezip').width(progress.percent + '%');
      $('#progress-text-filezip').text(`Compressing files: ${Math.round( progress.percent )}%`);
      if (progress.percent == 100) {
        $('#progress-text-filezip').text(`File compression complete`);
      }
    }).then(function(zippedFile) {
      formData.append('testdatum[testdata_file_list]', zippedFile, 'td.zip');

      var lastUpdate = (new Date().getTime()) - 500;
      var byterate = 0.0;
      var prevLoaded = 0;
      $.ajax({
        type: 'POST',
        url: url,
        data: formData,
        processData: false,
        contentType: false,
        xhr: function() {
          xhr = new window.XMLHttpRequest();
          xhr.upload.onprogress = function(evt) {
            if (evt.lengthComputable) {
              var now = new Date().getTime();
              $('#progress-fade-update').addClass('in');
              if (evt.loaded == evt.total) {
                $('#progress-inner-bar-update').width('100%');
                $('#progress-text-update').text('Processing...');
              } else if (now - lastUpdate >= 500) {
                var curByterate = ((evt.loaded - prevLoaded) / (now - lastUpdate)) * 1000;
                evt.byterate = byterate * 0.7 + curByterate * 0.3;
                byterate = evt.byterate;
                evt.byterate = curByterate;
                lastUpdate = now;
                prevLoaded = evt.loaded;
                $('#progress-text-update').text(_renderProgress(evt));
                $('#progress-inner-bar-update').width((evt.loaded / evt.total * 100) + '%');
              }
            }
          };
          return xhr;
        },
        success: function (data, status, nxhr) {
          if (xhr.responseURL != oldUrl) {
            window.history.pushState({}, null, xhr.responseURL);
          }
          document.querySelector('html').innerHTML = nxhr.responseText;
        },
        error: function (nxhr, status, error) {
          document.querySelector('html').innerHTML = nxhr.responseText;
        },
        abort: function() {
          $('#progress-fade-update').removeClass('in');
          $('#progress-inner-bar-update').width('0%');
        },
      });
    });
  });
});
</script>